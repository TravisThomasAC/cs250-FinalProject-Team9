---
title: "CMPSC 250 Final Project: Final Report"
author: "Xingbang Liu, Matt Jones, Travis Thomas"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document: default
subtitle: "Instructor: Dr. Mohan"
---
***

## Motivation

  Our team was inspired by existing music suggestion platforms (ie. Spotify, Pandora, Apple Music, etc,) to mimic their systems and add our own creative twist on current song suggesting algorithms. This includes features similar to other platforms including: "favorites" or "liked music", "DailyMix" and "Recommended for You", sorting features such as "by artist" and "by genre", and a "cloud database*" that would hold the list of all possible songs that the user can choose from.

  Our work also builds directly off the previous work submitted in this course, as well as building off existing algorithms in the field. We built directly off of the music-sorting lab we submitted earlier this year, to sort the users liked songs. The creative twist we added to our algorithm suggestion takes a look at how we listen to music from a different angle. Because music provides a "rhythm or beat" to many of the things we do (whether it's dancing, work, etc.), we decided to try to rate a user based on the speed of the rhythm (also known as Tempo).

#### Why is it important

  This work acts as valuable research to anyone in the music industry. Specifically, anyone who is looking at new ways to incorporate aspects of songs into a user-song-suggestion platform. While current music platforms are doing a good job of suggesting songs (usually based off other real peoples songs), there's still songs that users find out-of-the-blue on their own that they really enjoy. Exploring new ways to relate aspects of songs to the user can only help find these outlying songs, and suggest them to the user.

#### How is it useful

  Millions of people use music everyday. Whether it's to wake up to their favorite song in the morning, make their commute to their job better, or provide some-type of rhythm to everyday tasks, music makes our lives better! So, a tool which helps you find music you like, and save music you like would undoubtedly be useful to a lot of people.

## Background for problem

  There are many algorithms to find similar songs. Here are two examples of the Collaborative ???ltering:

#### Memory-based

  Generaly, user would be grouped in this algorithm. In this method, the algorithm will first track down people who have similar activities, then recommend songs to each other by their playlists. For example, action score could be assigned as:


  | Repeat song | Share | Like | Play | Played completely | Skip | Dislike |
  | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
  |   5   |   4   |   3   |   2   |   1   |   -1  |   -5  |

  Then, a persons preference would be a N-Dimensional vector. Here N is the number of songs by default. By using the cosine of the vector angle, which is generated by two vector, we can know how similar two users can be. The cosine of 0 degree, which means two people are exactly the same, is 1. The cosine of 180 degree, which means two people have the opposite preference, is -1. The equation is:

Assume we have vector $\vec a$ and $\vec b$,

$$cos(A) = \frac{\vec a \cdot \vec b}{|\vec a| \times |\vec b|}$$

  This prediction method is very accurate, but there are too many calculations and it is not accurate for a new user.

#### Model-based

  As for the second method, the algorithm will analyze the playlist of a person, then do recommendations. Models such as the latent factor are used in this method. In latent factor model, user's like list will be analyzed by dividing into different tag factors, for example, classic and indie. By signing scores for different factor, we can have a matrix which can divided into two different matrix:

$$R = QP^T$$
$$R_{user,song}= Q_{user,factor} P^T_{factor,song}$$
$$=
\begin{pmatrix}
  q_{user_{1},factor_{1}} & q_{user_{1},factor_{2}} & \cdots & q_{user_{1},factor_{n}} \\
  q_{user_{2},factor_{1}} & q_{user_{2},factor_{2}} & \cdots & q_{user_{2},factor_{n}} \\
  \vdots  & \vdots  & \ddots & \vdots \\
  q_{user_{n},factor_{1}} & q_{user_{n},factor_{2}} & \cdots & q_{user_{n},factor_{n}}
  \end{pmatrix}$$
$$
  \begin{pmatrix}
  p_{factor_{1},song_{1}} & p_{factor_{1},song_{2}} & \cdots & p_{factor_{1},song_{n}} \\
  p_{factor_{2},song_{1}} & p_{factor_{2},song_{2}} & \cdots & p_{factor_{2},song_{n}} \\
  \vdots  & \vdots  & \ddots & \vdots \\
  p_{factor_{n},song_{1}} & p_{factor_{n},song_{2}} & \cdots & p_{factor_{n},song_{n}}
  \end{pmatrix}^T$$

  From the matrix R, we can get estimated score. After that, we can ignore the song which the user already listened, and recommend him the song he has not listened.

  Of course, in the real world, if we implement algorithm based on song, the second dimension factor will rapidly increase. Plus there will be too many songs. Therefore, it will be more efficient if we calculate based on tags of the song. For example, for "The Sound of Silence" by Simon & Garfunel, tags can be Folk Rock, 60s, and Movie Track. Due to the time we have is limited, we would not build tags databases, therefore we would analyze by songs.

  In the real situation, based on different requirements, we can pick one of them or use them together. It is also an option to mix these two algorithms and form a new hybrid algorithm when there are not enough songs in a playlist.

#### How could it be improved

  These algorithms are not perfect, they could be limited when there are not enough users. For example, if a start up music service company wants to suggest songs to user, they have to use an algorithm which works when there are not enough users and user action data. In this situation, it would be better if the company could depend on the music only, for example, music metadata, rather than depend on user data. In our algorithm, we hard coded melody scores, From 1 to 10, the faster the higher, for each songs. This score simulated music classification data. By getting a mean score from user liked list, we can find more songs by their mean score. This method is more like a weaker version of the combination of nature language processing and raw audio analyze. In nature language processing, the program would analyze the lyrics, then get the emotion data. In raw audio analyze, the program would analyze the audio frames, and finally get an score for audio characteristic.  


## Algorithm Description

- Pseudocode
- Diagrams
- Time Complexities
- Previous algorithms

## Conclusion

#### Results

  While analyzing our results, note that our program doesn't take into account things like artist, genre, instruments used, etc. when suggesting songs. However, the program does take a unique approach to song suggesting, and runs without any bugs (caused by the user and/or built into our system).

  **Figure 1** shows the Main Menu of our program. It offers four options: Like (prints liked songs), Explore (Finds and adds new songs to the users liked songs), Daily Selection (Makes a playlist similar to the songs in the users liked-list), Quit (Exits the program)

  **Figure 2** shows the first feature: Print Liked Songs & Sort them.

  **Figure 3** shows the second feature: Finds 5 songs for the user, and the user picks a song (in this case, song 3) to add to their liked songs. Then **figure 4** shows the updated liked songs with new addition from feature #2.

  **Figure 5** shows the third feature: Gives you two song selections similar to your liked list tempo, and then the user adds these songs to their liked songs.

  **Figure 6** shows updated liked songs with new addition from feature #3.

  **Figure 7** shows the fourth feature: Quit/exits the program.

- Takeaways

#### Challenges

Their were a few obvious problems that our group encountered that was to be expected. Because our program has many different working parts, we had to split it up and then either comment the code in a way so that our other group members could explain it. Alternatively to commenting every bit of code, we also met many times to try to explain our code to the rest of the group.
	The biggest challenge our group had was working with the "cloud music list" (aka our Music.csv) and figuring out how to edit this list without messing us the csv file and the rest of our program. Our solution was to make a "working csv file" (Test.csv)  that was the file we actually made edits to, while the "cloud file" (Music.csv) was left alone so that the edits didn't cause any problems with the rest of the program.

- Rewards

## Index

 ![menu](../images/menu.png)

 ![print Liked Songs & Sort them](../images/likeList.PNG)

 ![explore](../images/explore.PNG)

 ![updated liked songs](../images/updated.png)

 ![suggestion](../images/suggestion.PNG)

 ![updated liked songs](../images/new.png)

 ![Quit/exits](../images/quit.png)
